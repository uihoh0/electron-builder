{"version":3,"file":"localZip.js","sourceRoot":"","sources":["../../src/differentialUpdate/localZip.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\"\nimport { close as closeFile, fstat, open, read } from \"fs-extra-p\"\nimport { Entry, eocdrWithoutCommentSize, readCentralDirectoryEntry, ZipFileReader } from \"./zip\"\n\n// promisified and optimized version of yauzl (read Central Directory Entry buffer in one read call)\n\nexport interface ZipOptions {\n  decodeStrings?: boolean\n  validateEntrySizes?: boolean\n\n  ignoreComments?: boolean\n}\n\nexport async function openZip(file: string, options?: ZipOptions | null): Promise<ZipFile> {\n  const finalOptions: ZipOptions = {\n    ignoreComments: true,\n    validateEntrySizes: true,\n    decodeStrings: true,\n    ...options,\n  }\n\n  const fd = await open(file, \"r\")\n  try {\n    const stats = await fstat(fd)\n    return await readEndOfCentralDirectoryRecord(fd, stats.size, finalOptions)\n  }\n  catch (e) {\n    await closeFile(fd)\n    throw e\n  }\n}\n\nasync function readEndOfCentralDirectoryRecord(fd: number, totalSize: number, options: ZipOptions) {\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\")\n  }\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n   // 2-byte size\n  const bufferSize = Math.min(eocdrWithoutCommentSize + 65535, totalSize)\n  const buffer = Buffer.allocUnsafe(bufferSize)\n  const bufferReadStart = totalSize - bufferSize\n\n  await readAndAssertNoEof(fd, buffer, 0, bufferSize, bufferReadStart)\n  const zipFileReader = readCentralDirectoryEntry(buffer)\n  return new ZipFile(fd, zipFileReader, totalSize, options)\n}\n\nexport class ZipFile extends EventEmitter {\n  private isOpen = true\n\n  // noinspection JSUnusedGlobalSymbols\n  constructor(readonly fd: number, readonly zipReader: ZipFileReader, readonly fileSize: number, readonly options: ZipOptions) {\n    super()\n  }\n\n  async readEntries(): Promise<Array<Entry>> {\n    const buffer = Buffer.allocUnsafe(this.zipReader.centralDirectorySize)\n    await readAndAssertNoEof(this.fd, buffer, 0, buffer.length, this.zipReader.centralDirectoryOffset)\n    return this.zipReader.readEntries(buffer)\n  }\n\n  async close() {\n    if (!this.isOpen) {\n      return\n    }\n\n    this.isOpen = false\n    return closeFile(this.fd)\n  }\n\n  async readEntryData(entry: Entry) {\n    const buffer = Buffer.allocUnsafe(entry.compressedSize)\n    await read(this.fd, buffer, 0, entry.compressedSize, entry.dataStart)\n    return buffer\n  }\n}\n\nasync function readAndAssertNoEof(fd: number, buffer: Buffer, offset: number, length: number, position: number) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return Buffer.alloc(0)\n  }\n\n  // noinspection UnnecessaryLocalVariableJS\n  const result = await read(fd, buffer, offset, length, position)\n  //   if (bytesRead < length) {\n  //     return callback(new Error(\"unexpected EOF\"))\n  //   }\n  return result\n}"]}
