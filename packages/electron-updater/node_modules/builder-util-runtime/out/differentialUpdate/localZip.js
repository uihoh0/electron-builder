"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ZipFile = exports.openZip = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

let openZip = exports.openZip = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file, options) {
        const finalOptions = Object.assign({ ignoreComments: true, validateEntrySizes: true, decodeStrings: true }, options);
        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(file, "r");
        try {
            const stats = yield (0, (_fsExtraP || _load_fsExtraP()).fstat)(fd);
            return yield readEndOfCentralDirectoryRecord(fd, stats.size, finalOptions);
        } catch (e) {
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            throw e;
        }
    });

    return function openZip(_x, _x2) {
        return _ref.apply(this, arguments);
    };
})();

let readEndOfCentralDirectoryRecord = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (fd, totalSize, options) {
        if (totalSize > Number.MAX_SAFE_INTEGER) {
            throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
        }
        // eocdr means End of Central Directory Record.
        // search backwards for the eocdr signature.
        // the last field of the eocdr is a variable-length comment.
        // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
        // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
        // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
        // 2-byte size
        const bufferSize = Math.min((_zip || _load_zip()).eocdrWithoutCommentSize + 65535, totalSize);
        const buffer = Buffer.allocUnsafe(bufferSize);
        const bufferReadStart = totalSize - bufferSize;
        yield readAndAssertNoEof(fd, buffer, 0, bufferSize, bufferReadStart);
        const zipFileReader = (0, (_zip || _load_zip()).readCentralDirectoryEntry)(buffer);
        return new ZipFile(fd, zipFileReader, totalSize, options);
    });

    return function readEndOfCentralDirectoryRecord(_x3, _x4, _x5) {
        return _ref2.apply(this, arguments);
    };
})();

let readAndAssertNoEof = (() => {
    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (fd, buffer, offset, length, position) {
        if (length === 0) {
            // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
            return Buffer.alloc(0);
        }
        // noinspection UnnecessaryLocalVariableJS
        const result = yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, buffer, offset, length, position);
        //   if (bytesRead < length) {
        //     return callback(new Error("unexpected EOF"))
        //   }
        return result;
    });

    return function readAndAssertNoEof(_x6, _x7, _x8, _x9, _x10) {
        return _ref3.apply(this, arguments);
    };
})();
//# sourceMappingURL=localZip.js.map


var _events;

function _load_events() {
    return _events = require("events");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _zip;

function _load_zip() {
    return _zip = require("./zip");
}

class ZipFile extends (_events || _load_events()).EventEmitter {
    // noinspection JSUnusedGlobalSymbols
    constructor(fd, zipReader, fileSize, options) {
        super();
        this.fd = fd;
        this.zipReader = zipReader;
        this.fileSize = fileSize;
        this.options = options;
        this.isOpen = true;
    }
    readEntries() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const buffer = Buffer.allocUnsafe(_this.zipReader.centralDirectorySize);
            yield readAndAssertNoEof(_this.fd, buffer, 0, buffer.length, _this.zipReader.centralDirectoryOffset);
            return _this.zipReader.readEntries(buffer);
        })();
    }
    close() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (!_this2.isOpen) {
                return;
            }
            _this2.isOpen = false;
            return (0, (_fsExtraP || _load_fsExtraP()).close)(_this2.fd);
        })();
    }
    readEntryData(entry) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const buffer = Buffer.allocUnsafe(entry.compressedSize);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(_this3.fd, buffer, 0, entry.compressedSize, entry.dataStart);
            return buffer;
        })();
    }
}
exports.ZipFile = ZipFile;