"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const path = require("path");
const fs_extra_p_1 = require("fs-extra-p");
const bluebird_lst_1 = require("bluebird-lst");
const PackageGraph_1 = require("./PackageGraph");
const globSuffix = "/*";
async function transpile(transpilator) {
    const paths = process.argv.slice(2);
    if (paths.length == 0) {
        paths.push(process.cwd());
    }
    if (paths[0].endsWith(globSuffix)) {
        const packageDir = paths[0].substring(0, paths[0].length - 2);
        const packageMetadata = await readProjectMetadata(packageDir);
        const toCompile = PackageGraph_1.topologicallyBatchPackages(packageMetadata);
        await bluebird_lst_1.default.mapSeries(toCompile, it => {
            console.log(`Building ${it.map(it => it.name).join(", ")}`);
            return transpilePaths(it.map(it => path.join(packageDir, it.name)), transpilator, false);
        });
    }
    await transpilePaths(paths.filter(it => !it.endsWith(globSuffix)), transpilator, true);
}
exports.transpile = transpile;
async function readProjectMetadata(packageDir) {
    const packageDirs = bluebird_lst_1.default.filter((await fs_extra_p_1.readdir(packageDir)).filter(it => !it.includes(".")).sort(), it => {
        return fs_extra_p_1.stat(path.join(packageDir, it, "tsconfig.json"))
            .then(it => it.isFile())
            .catch(() => false);
    });
    return await bluebird_lst_1.default.map(packageDirs, it => fs_extra_p_1.readJson(path.join(packageDir, it, "package.json")), { concurrency: 8 });
}
exports.readProjectMetadata = readProjectMetadata;
async function transpilePaths(paths, transpilator, isLogBuilding) {
    for (const basePath of paths) {
        if (isLogBuilding) {
            console.log(`Building ${basePath}`);
        }
        try {
            await build(basePath, transpilator);
        }
        catch (e) {
            if (!(e instanceof CompilationError)) {
                throw e;
            }
            for (const diagnostic of e.errors) {
                if (diagnostic.file == null) {
                    console.log(diagnostic.messageText);
                    continue;
                }
                const location = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
                const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                console.log(`${diagnostic.file.fileName} (${location.line + 1}, ${location.character + 1}): ${message}`);
            }
            process.exit(-1);
            return;
        }
    }
}
async function build(basePath, transpilator) {
    const tsConfigPath = path.join(basePath, "tsconfig.json");
    const jsonResult = ts.parseConfigFileTextToJson(tsConfigPath, await fs_extra_p_1.readFile(tsConfigPath, "utf8"));
    if (jsonResult.error != null) {
        throw new CompilationError([jsonResult.error]);
    }
    const result = ts.parseJsonConfigFileContent(jsonResult.config, ts.sys, basePath);
    checkErrors(result.errors);
    await transpilator(basePath, result, jsonResult.config);
}
function checkErrors(errors) {
    if (errors.length !== 0) {
        throw new CompilationError(errors);
    }
}
exports.checkErrors = checkErrors;
class CompilationError extends Error {
    constructor(errors) {
        super("Compilation error");
        this.errors = errors;
    }
}
//# sourceMappingURL=util.js.map