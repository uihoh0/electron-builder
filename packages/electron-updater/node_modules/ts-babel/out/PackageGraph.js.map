{"version":3,"file":"PackageGraph.js","sourceRoot":"","sources":["../src/PackageGraph.ts"],"names":[],"mappings":"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","sourcesContent":["// lerna\n\nexport class PackageGraphNode {\n  readonly dependencies: Array<string> = []\n\n  constructor(readonly metadata: any) {\n  }\n}\n\nexport interface PackageMetadata {\n  name: string\n}\n\nexport class PackageGraph {\n  readonly nodes: Array<PackageGraphNode> = []\n  readonly nodesByName: any = {}\n\n  constructor(readonly packageMetadataList: Array<PackageMetadata>) {\n    for (const packageMetadata of packageMetadataList) {\n      const node = new PackageGraphNode(packageMetadata)\n      this.nodes.push(node)\n      this.nodesByName[packageMetadata.name] = node\n    }\n\n    for (const node of this.nodes) {\n      const addDeps = (dependencies: Array<any>) => {\n        const depNames = Object.keys(dependencies)\n        for (const depName of depNames) {\n          const packageNode = this.nodesByName[depName]\n          if (packageNode != null) {\n            node.dependencies.push(depName)\n          }\n        }\n      }\n\n      const dependencies = node.metadata.dependencies\n      if (dependencies != null) {\n        addDeps(dependencies)\n      }\n      const peerDependencies = node.metadata.peerDependencies\n      if (peerDependencies != null) {\n        addDeps(peerDependencies)\n      }\n    }\n  }\n\n  get(packageName: string): PackageGraphNode {\n    return this.nodesByName[packageName]\n  }\n}\n\n\nexport function topologicallyBatchPackages(packages: Array<any>) {\n  packages = packages.slice()\n  const packageGraph = new PackageGraph(packages)\n\n  // This maps package names to the number of packages that depend on them.\n  // As packages are completed their names will be removed from this object.\n  const refCounts: any = {}\n  for (const pkg of packages) {\n    for (const dep of packageGraph.get(pkg.name).dependencies) {\n      if (refCounts[dep] == null) {\n        refCounts[dep] = 0\n      }\n      refCounts[dep]++\n    }\n  }\n\n  const batches = []\n  while (packages.length > 0) {\n    // Get all packages that have no remaining dependencies within the repo that haven't yet been picked.\n    const batch = packages.filter(pkg => {\n      const node = packageGraph.get(pkg.name)\n      return node.dependencies.filter(dep => refCounts[dep]).length == 0\n    });\n\n    // If we weren't able to find a package with no remaining dependencies,\n    // then we've encountered a cycle in the dependency graph.  Run a single-package batch with the package that has the most dependents.\n    if (packages.length > 0 && !batch.length) {\n      console.warn(\"Encountered a cycle in the dependency graph. This may cause instability!\")\n      batch.push(packages.reduce((a, b) => (refCounts[a.name] || 0) > (refCounts[b.name] || 0) ? a : b))\n    }\n\n    batches.push(batch)\n\n    for (const pkg of batch) {\n      delete refCounts[pkg.name]\n      packages.splice(packages.indexOf(pkg), 1)\n    }\n  }\n\n  return batches\n}\n"]}