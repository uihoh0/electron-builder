#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("v8-compile-cache");
const ts = require("typescript");
const path = require("path");
const babel = require("@babel/core");
const fs_extra_p_1 = require("fs-extra-p");
const bluebird_lst_1 = require("bluebird-lst");
const util_1 = require("./util");
util_1.transpile(async (basePath, config, tsConfig) => {
    const compilerOptions = config.options;
    if (tsConfig.declaration !== false) {
        compilerOptions.declaration = true;
    }
    compilerOptions.noEmitOnError = true;
    const program = ts.createProgram(config.fileNames, compilerOptions, ts.createCompilerHost(compilerOptions));
    util_1.checkErrors(ts.getPreEmitDiagnostics(program));
    const compilerOutDir = path.resolve(program.getCurrentDirectory(), compilerOptions.outDir);
    if (compilerOutDir == null) {
        throw new Error("outDir is not specified in the compilerOptions");
    }
    await fs_extra_p_1.ensureDir(compilerOutDir);
    const fileToSourceMap = {};
    const promises = [];
    const emittedFiles = new Set();
    const currentDirectory = program.getCurrentDirectory();
    const emitResult = program.emit(undefined, (fileName, data) => {
        const file = path.resolve(currentDirectory, fileName);
        emittedFiles.add(file);
        if (file.endsWith(".js")) {
            const sourceMapFileName = `${file}.map`;
            processCompiled(data, fileToSourceMap[sourceMapFileName], file, sourceMapFileName, promises, currentDirectory);
        }
        else if (file.endsWith(".js.map")) {
            fileToSourceMap[file] = data;
        }
        else {
            promises.push(fs_extra_p_1.outputFile(file, data));
        }
    });
    util_1.checkErrors(emitResult.diagnostics);
    if (emitResult.emitSkipped) {
        throw new Error("Emit skipped");
    }
    await Promise.all(promises);
    await removeOld(compilerOutDir, emittedFiles);
})
    .catch(error => {
    console.error(error.stack || error.message || error);
    // noinspection TypeScriptValidateJSTypes
    process.exit(-1);
});
async function removeOld(outDir, emittedFiles) {
    await bluebird_lst_1.default.map(await fs_extra_p_1.readdir(outDir), file => {
        const fullPath = path.resolve(outDir, file);
        if (!file.includes(".")) {
            return removeOld(fullPath, emittedFiles);
        }
        if ((file.endsWith(".js") || file.endsWith(".js.map") || file.endsWith(".d.ts")) && !emittedFiles.has(fullPath)) {
            return fs_extra_p_1.unlink(fullPath);
        }
        return null;
    });
}
function processCompiled(code, sourceMap, jsFile, sourceMapFileName, promises, currentDirectory) {
    const options = {
        inputSourceMap: sourceMap == null ? null : JSON.parse(sourceMap),
        sourceMaps: true,
        filename: jsFile,
        root: currentDirectory,
    };
    const result = babel.transform(code, options);
    const match = code.match(regex);
    const sourceMapUrl = match[1] || match[2];
    // add marker, so, babel-jest can easily detect is file required to be processed or not (maybe processed by IDE TS compiler)
    promises.push(fs_extra_p_1.outputFile(jsFile, result.code.replace(regex, "") + `\n// __ts-babel@6.0.4` + `\n//# sourceMappingURL=${sourceMapUrl}`), fs_extra_p_1.outputJson(sourceMapFileName, result.map));
}
const innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
const regex = RegExp("(?:" +
    "/\\*" +
    "(?:\\s*\r?\n(?://)?)?" +
    "(?:" + innerRegex.source + ")" +
    "\\s*" +
    "\\*/" +
    "|" +
    "//(?:" + innerRegex.source + ")" +
    ")" +
    "\\s*");
//# sourceMappingURL=builder.js.map